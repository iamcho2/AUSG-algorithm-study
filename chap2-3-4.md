# 2장

* 정규화 : 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로는 똑같은 것들을 그룹으로 묶은 뒤, 각 그룹의 대표들만을 고려하는 방법
* 41쪽 4번 이해 제대로 못함 다시 읽기



# 3장

* vector<int>&array <-- 왜 참조형인지, vector 에 대한 이해 ,,
* for_each(InputIterator first, InputIterator last, fn)
  * 범위 : [first, last)
* 정규화는 자료를 입력받거나 계산하자마자 곧장 이루어져야 함
  * 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나
  * 외부에서 자료를 입력받자마자 정규화 수행
* off-by-one 오류
  * 방지할 수 있는 좋은 방법 : 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지 되새겨보기
* 56쪽 왜 const& 형태..?
* 자바의 표준 라이브러리가 < 연산 대신에 <= 연산을 비교 함수의 모델로 쓴다
* 최소공배수 lcm(a,b) = a*b/gcd(a,b)
* 자료형의 프로모션
  * 두 개의 피연산자를 같은 자료형으로 변환해서 계산하는 것
  * c++ 의 경우
  * 부호 없는 정수형과 부호 있는 정수형이 섞여 있을 경우 : 부호 없는 정수형으로 변환됨



# 4장

* 알고리즘은 문제를 해결하는 방법 그 자체를 가리킴
* 소스코드가 알고리즘을 정의하는 것이 아님
* 알고리즘의 수행 시간 - 반복문이 지배 (입력의 크기가 커지면 커질수록)
  * 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현
* M-이동-평균은 마지막 M개의 관찰값의 평균으로 정의
* 선형 시간 알고리즘
* 이진 탐색 binsearch(A[],x) = 오름차순으로 정렬된 배열 A[]와 찾고 싶은 값 x가 주어질 때 A[i-1]<x<=A[i]인 i를 반환한다. 이때 A[-1]= -∞, A[N]=∞로 가정한다.
* 콜백 함수
* 103쪽 코드 4.5
  * //이 음식을 만들지 않는 경우의 답을 계산한다 부터 이해 안됨 .. ..